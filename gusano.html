<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Un juego clásico de snake en 3D usando Three.js. Controla un gusano en un plano tridimensional, come comida y evita chocar." />
  <meta name="keywords" content="snake, 3d, game, three.js, gusano, juego" />
  <meta name="author" content="A&G Programación y Desarrollo de Sistemas Informáticos S.A." />
  <link rel="icon" type="image/x-icon" href="favicon.ico" />
  <link rel="icon" type="image/png" sizes="32x32" href="logoworm3d.png" />
  <link rel="apple-touch-icon" href="logoworm3d.png" />
  <title>Gusano 3D</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }

    canvas {
      display: block;
    }
    #ui {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
      text-align: center;
      pointer-events: none;
    }

    #score {
    position: absolute;
    top: 12px;
    left: 12px;
    color: #fff;
    font-size: 18px;
    font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    z-index: 1000;
    padding: 8px 12px;
    background: linear-gradient(135deg, rgba(255,255,255,0.06), rgba(0,0,0,0.12));
    border-radius: 10px;
    -webkit-backdrop-filter: blur(6px) saturate(120%);
    backdrop-filter: blur(6px) saturate(120%);
    box-shadow: 0 6px 22px rgba(0,0,0,0.45);
    letter-spacing: 0.6px;
    transition: transform 180ms ease, box-shadow 160ms ease;
    will-change: transform;
    }

    #score.pulse { transform: scale(1.08); box-shadow: 0 10px 34px rgba(0,0,0,0.6); }

    #logo {
    position: absolute;
    top: 10px;
    right: 10px;
    height: 40px; /* o usa width si prefieres */
    z-index: 10;
    }

    #touch-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    z-index: 1050;
    -webkit-user-select: none;
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: flex-end;
    pointer-events: auto;
    padding: 8px;
    border-radius: 12px;
    background: rgba(0,0,0,0.18);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    }

    #touch-controls .up {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 0;
    margin: 0px !important;
    margin-top: 3px !important;
    }

    #touch-controls .row {
    display: flex;
    justify-content: center;
    margin-top: 45px; /* Ajusta este valor si es necesario */
    }

    #touch-controls .btn {
    width: 48px;
    height: 48px;
    margin: 4px;
    font-size: 22px;
    background-color: rgba(255,255,255,0.2);
    border: 1px solid #fff;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    -webkit-backdrop-filter: blur(4px) saturate(120%);
    backdrop-filter: blur(4px) saturate(120%);
    }

    #touch-controls .btn:active {
    background-color: rgba(255,255,255,0.4);
    }

    /* Start overlay */
    #start-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      pointer-events: none;
    }
    #start-overlay[aria-hidden="true"] {
      display: none;
    }
    #game-over-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      pointer-events: none;
    }
    #game-over-overlay[aria-hidden="true"] {
      display: none;
    }
    #start-overlay .start-inner{
      pointer-events: auto;
      background: linear-gradient(180deg, rgba(8,10,12,0.9), rgba(0,0,0,0.76));
      border-radius: 16px;
      padding: 18px 26px;
      text-align: center;
      box-shadow: 0 18px 46px rgba(0,0,0,0.6);
      color: #fff;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    }
    #audio-toggle {
      margin-left: 8px;
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 6px 8px;
      font-size: 14px;
      border-radius: 8px;
    }
    #audio-toggle:hover { opacity: 0.9; cursor: pointer; }
    #music-volume-slider, #effects-volume-slider {
      width: 150px;
      margin-top: 10px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255,255,255,0.1);
      height: 6px;
      border-radius: 3px;
      outline: none;
    }
    #music-volume-slider::-webkit-slider-thumb, #effects-volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ff7b00;
      cursor: pointer;
    }
    #music-volume-slider::-moz-range-thumb, #effects-volume-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ff7b00;
      cursor: pointer;
      border: none;
    }
    label[for="music-volume-slider"], label[for="effects-volume-slider"] {
      display: block;
      margin-top: 10px;
      color: #fff;
      font-size: 14px;
    }
    #start-overlay .title { max-width: 150px; height: auto; margin: 0 auto; display: block; }
    #start-overlay .subtitle { margin-top:8px; opacity:0.9; }
    #start-overlay .start-inner button{
      margin-top: 14px;
      padding: 10px 18px;
      font-size: 18px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: linear-gradient(90deg,#ff7b00,#ff4500);
      color: white;
      box-shadow: 0 8px 22px rgba(255,123,0,0.18);
    }

    /* Game Over overlay styles - same as start overlay */
    #game-over-overlay .start-inner {
      pointer-events: auto;
      background: linear-gradient(180deg, rgba(8,10,12,0.9), rgba(0,0,0,0.76));
      border-radius: 16px;
      padding: 18px 26px;
      text-align: center;
      box-shadow: 0 18px 46px rgba(0,0,0,0.6);
      color: #fff;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    }
    #game-over-overlay .title { font-size:22px; font-weight:700; }
    #game-over-overlay img.title { max-width: 150px; height: auto; margin: 0 auto; display: block; }
    #game-over-overlay .subtitle { margin-top:8px; opacity:0.9; }
    #game-over-overlay .start-inner button{
      margin-top: 14px;
      padding: 10px 18px;
      font-size: 18px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: linear-gradient(90deg,#ff7b00,#ff4500);
      color: white;
      box-shadow: 0 8px 22px rgba(255,123,0,0.18);
    }
    #rotate-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.88);
      color: #fff;
      z-index: 9999;
      visibility: hidden;
      opacity: 0;
      transition: opacity 220ms ease, visibility 220ms ease;
      pointer-events: none;
      font-family: sans-serif;
      text-align: center;
    }
    #rotate-overlay.show {
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    #rotate-overlay .rotate-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 18px;
    }
    #rotate-overlay .rotate-icon {
      width: 96px;
      height: 96px;
      opacity: 0.98;
    }
    #rotate-overlay .rotate-text {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.6px;
    }
    @media (max-width:600px) {
      #rotate-overlay .rotate-icon { width: 72px; height:72px; }
      #rotate-overlay .rotate-text { font-size: 16px; }
    }

  </style>
</head>
<body>
<div id="ui"></div>

<!-- Rotate overlay: shown on mobile when in portrait orientation -->
<div id="rotate-overlay" class="" role="dialog" aria-hidden="true" tabindex="-1">
  <div class="rotate-inner" aria-hidden="true">
    <svg class="rotate-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M12 6V3L8 7l4 4V8c2.76 0 5 2.24 5 5 0 2.21-1.45 4.08-3.5 4.72" stroke="#ffffff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M20 6v6" stroke="#ffffff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" opacity="0.85"/>
    </svg>
    <div class="rotate-text">Gira la pantalla</div>
  </div>
</div>
<div id="score">Puntaje: 0</div>
<img id="logo" src="logo.png" alt="Logo">
<div id="touch-controls">
  <button class="btn up">▲</button>
  <div class="row">
    <button class="btn left">◀</button>
    <button class="btn down">▼</button>
    <button class="btn right">▶</button>
  </div>
</div>
<!-- Optional Start overlay with CTA -->
<div id="start-overlay">
  <div class="start-inner">
    <img src="logoworm3d.png" alt="Gusano 3D" class="title">
    <div class="subtitle">Presiona 'Comenzar' o toca la pantalla para jugar</div>
    <button id="start-button">Comenzar</button>
    <button id="audio-toggle">Musica: On</button>
    <label for="music-volume-slider">Volumen Música:</label>
    <input type="range" id="music-volume-slider" min="0" max="1" step="0.01" value="0.5">
    <label for="effects-volume-slider">Volumen Efectos:</label>
    <input type="range" id="effects-volume-slider" min="0" max="1" step="0.01" value="0.5">
  </div>
</div>
<!-- Game Over overlay with same design -->
<div id="game-over-overlay" aria-hidden="true">
  <div class="start-inner">
    <img src="logoworm3d.png" alt="Gusano 3D" class="title">
    <div class="title">¡Perdiste!</div>
    <div class="subtitle">Puntaje: <span id="final-score">0</span></div>
    <button id="restart-button">Reiniciar</button>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.js"></script>
<script src="./soundmanager.js"></script>
<script>
let scene, camera, renderer, clock;
let eyes = [];
let pupils = [];
let snake = [];
let direction = new THREE.Vector3(1, 0, 0);
let food;
let running = false;
let gameOver = false;
let moveTimer = 0;
let moveInterval = 0.15;
let score = 0;
let gridSize = 20;
let plane = null;
let textureBack = null;
let snakeGroup;
let particles = []; // small particle effects when eating
let beams = []; // laser beams when eating (red/blue rays)
let borderRays = []; // flashing red border rays
// Colors from logo reference
const PALETTE = {
  blue: 0x3A78FF,
  orange: 0xFF6A00,
  cyan: 0x56FFD8,
  red: 0xFF2E2E
};
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const ui = document.getElementById('ui');

init();
createAnimatedBackground();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  /*camera.position.set(gridSize / 2, 25, gridSize * 1.2);
  camera.lookAt(gridSize / 2, 0, gridSize / 2);*/

  camera.position.set(gridSize / 2, 15, gridSize * 0.6); // Acercar la cámara a la escena
  camera.lookAt(gridSize / 2, 0, gridSize / 2); // Mantener el enfoque en el centro

  renderer = new THREE.WebGLRenderer({ antialias: true });
  // Shadows and better lighting for nicer visuals
  try {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  } catch (e) {}
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  

  clock = new THREE.Clock();

  // Luz
  const ambient = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambient);
  // Hemispheric light for soft sky/ground lighting
  const hemi = new THREE.HemisphereLight(0x8888ff, 0x222222, 0.25);
  scene.add(hemi);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(10, 20, 10);
  // enable shadows for directional light
  try {
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 200;
  } catch (e) {}
  scene.add(dirLight);

  // Plano base
  const grid = new THREE.GridHelper(gridSize, gridSize, 0x2f7bff, 0x0a0c12);
  grid.position.set(gridSize / 2 - 0.5, -0.5, gridSize / 2 - 0.5);
  scene.add(grid);

  // Flashing red border rays to indicate boundaries
  const rayMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xff0000, 
    emissive: 0xff0000, 
    emissiveIntensity: 0.5,
    transparent: true,
    opacity: 0.8
  });
  // Bottom border: z=-1, x=-0.5 to 19.5, cylinder along x
  const bottomGeometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 8);
  const bottomRay = new THREE.Mesh(bottomGeometry, rayMaterial.clone());
  bottomRay.position.set(9.5, 0.5, -0.5); // moved down by 1 unit
  bottomRay.rotation.z = Math.PI / 2;
  scene.add(bottomRay);
  borderRays.push(bottomRay);
  // Top border: z=19, x=-0.5 to 19.5
  const topGeometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 8);
  const topRay = new THREE.Mesh(topGeometry, rayMaterial.clone());
  topRay.position.set(9.5, 0.5, 19.5); // moved closer by 0.5
  topRay.rotation.z = Math.PI / 2;
  scene.add(topRay);
  borderRays.push(topRay);
  // Left border: x=-0.5, z=-0.5 to 19.5, cylinder along z
  const leftGeometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 8);
  const leftRay = new THREE.Mesh(leftGeometry, rayMaterial.clone());
  leftRay.position.set(-0.5, 0.5, 9.5);
  leftRay.rotation.x = Math.PI / 2; // rotate to lie along z
  scene.add(leftRay);
  borderRays.push(leftRay);
  // Right border: x=19.5, z=-0.5 to 19.5
  const rightGeometry = new THREE.CylinderGeometry(0.02, 0.02, 20, 8);
  const rightRay = new THREE.Mesh(rightGeometry, rayMaterial.clone());
  rightRay.position.set(19.5, 0.5, 9.5);
  rightRay.rotation.x = Math.PI / 2; // rotate to lie along z
  scene.add(rightRay);
  borderRays.push(rightRay);

  // Neon accent lights for atmosphere
  try {
    const blueLight = new THREE.PointLight(PALETTE.blue, 0.6, 40);
    blueLight.position.set(gridSize / 2, 10, -5);
    scene.add(blueLight);
    const orangeLight = new THREE.PointLight(PALETTE.orange, 0.6, 40);
    orangeLight.position.set(gridSize + 5, 8, gridSize + 5);
    scene.add(orangeLight);
  } catch (e) {}

  // Snake
  snakeGroup = new THREE.Group();
  scene.add(snakeGroup);

  document.addEventListener('keydown', onKey);
  document.addEventListener('touchstart', onTouch);
  window.addEventListener('resize', onWindowResize);

  if (true) {
    document.getElementById('touch-controls').style.display = 'block';

    //
    document.querySelector('#touch-controls .up').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.z !== 1) direction.set(0, 0, -1);
      updateEyeDirection();
    });
    document.querySelector('#touch-controls .down').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.z !== -1) direction.set(0, 0, 1);
      updateEyeDirection();
    });
    document.querySelector('#touch-controls .left').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.x !== 1) direction.set(-1, 0, 0);
      updateEyeDirection();
    });
    document.querySelector('#touch-controls .right').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.x !== -1) direction.set(1, 0, 0);
      updateEyeDirection();
    });
  }

  
  resetGame();
  //
  
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKey(e) {
  if (e.code === "Space") {
    if (!running || gameOver) {
      startGame();
    }
  }
  if (e.key === "ArrowUp" || e.key === "w") if (direction.z !== 1) direction.set(0, 0, -1);
  if (e.key === "ArrowDown" || e.key === "s") if (direction.z !== -1) direction.set(0, 0, 1);
  if (e.key === "ArrowLeft" || e.key === "a") if (direction.x !== 1) direction.set(-1, 0, 0);
  if (e.key === "ArrowRight" || e.key === "d") if (direction.x !== -1) direction.set(1, 0, 0);
  updateEyeDirection();
  try { if (typeof soundManager !== 'undefined') soundManager.playMove(); } catch (e) {}
}

function onTouch(e) {
  if (e.target.tagName === 'BUTTON') return; // don't start game on button click
  if (!running || gameOver) {
    startGame();
  }
}

function startGame() {
  resetGame();
  running = true;
  ui.style.display = "none";
  try { 
    const musicEnabled = (localStorage.getItem('worm_music') || 'true') === 'true';
    if (musicEnabled && typeof soundManager !== 'undefined') {
      const savedMusicVolume = parseFloat(localStorage.getItem('worm_music_volume') || '0.5');
      soundManager.setMusicVolume(savedMusicVolume);
      soundManager.startBackground(); 
    }
    const savedEffectsVolume = parseFloat(localStorage.getItem('worm_effects_volume') || '0.5');
    soundManager.setEffectsVolume(savedEffectsVolume);
  } catch (e) {}
  try {
    const overlay = document.getElementById('start-overlay');
    if (overlay) {
      if (overlay.contains(document.activeElement)) document.activeElement.blur();
      overlay.setAttribute('aria-hidden', 'true');
    }
    const goOverlay = document.getElementById('game-over-overlay');
    if (goOverlay) {
      if (goOverlay.contains(document.activeElement)) document.activeElement.blur();
      goOverlay.setAttribute('aria-hidden', 'true');
    }
  } catch (e) {}
}

// Setup start button so user can click to start
document.addEventListener('DOMContentLoaded', function () {
  try {
    const btn = document.getElementById('start-button');
    if (btn) btn.addEventListener('click', startGame);
    const restartBtn = document.getElementById('restart-button');
    if (restartBtn) restartBtn.addEventListener('click', resetGame);
    // Audio toggle
    let musicEnabled = (localStorage.getItem('worm_music') || 'true') === 'true';
    const audioBtn = document.getElementById('audio-toggle');
    function updateAudioButton() {
      if (!audioBtn) return;
      audioBtn.textContent = 'Musica: ' + (musicEnabled ? 'On' : 'Off');
    }
    updateAudioButton();
    if (audioBtn) {
      audioBtn.addEventListener('click', () => {
        musicEnabled = !musicEnabled;
        localStorage.setItem('worm_music', musicEnabled ? 'true' : 'false');
        updateAudioButton();
        try {
          if (musicEnabled) {
            if (typeof soundManager !== 'undefined') soundManager.startBackground();
          } else {
            if (typeof soundManager !== 'undefined') soundManager.stopBackground();
          }
        } catch (e) {}
      });
    }
    // Volume sliders
    const musicVolumeSlider = document.getElementById('music-volume-slider');
    if (musicVolumeSlider) {
      const savedMusicVolume = parseFloat(localStorage.getItem('worm_music_volume') || '0.5');
      musicVolumeSlider.value = savedMusicVolume;
      soundManager.setMusicVolume(savedMusicVolume);
      musicVolumeSlider.addEventListener('input', (e) => {
        const vol = parseFloat(e.target.value);
        soundManager.setMusicVolume(vol);
        localStorage.setItem('worm_music_volume', vol.toString());
      });
    }
    const effectsVolumeSlider = document.getElementById('effects-volume-slider');
    if (effectsVolumeSlider) {
      const savedEffectsVolume = parseFloat(localStorage.getItem('worm_effects_volume') || '0.5');
      effectsVolumeSlider.value = savedEffectsVolume;
      soundManager.setEffectsVolume(savedEffectsVolume);
      effectsVolumeSlider.addEventListener('input', (e) => {
        const vol = parseFloat(e.target.value);
        soundManager.setEffectsVolume(vol);
        localStorage.setItem('worm_effects_volume', vol.toString());
      });
    }
  } catch (e) {}
});

function resetGame() {
  snake.forEach(part => snakeGroup.remove(part.mesh));
  snake = [];
  direction.set(1, 0, 0);
  // Start with a neon head color inspired by logo
  snake.push({ x: 10, z: 10, mesh: createCube(10, 10, true, PALETTE.cyan) });
  moveTimer = 0;
  gameOver = false;
  running = false;
  score = 0;
  placeFood();
  //ui.innerText = "Presiona espacio o toca la pantalla para comenzar";
  ui.style.display = "flex";
  try {
    const goOverlay = document.getElementById('game-over-overlay');
    if (goOverlay) {
      if (goOverlay.contains(document.activeElement)) document.activeElement.blur();
      goOverlay.setAttribute('aria-hidden', 'true');
    }
    const startOverlay = document.getElementById('start-overlay');
    if (startOverlay) startOverlay.setAttribute('aria-hidden', 'false');
  } catch (e) {}
}





function createAnimatedBackground() {
  // Crear un canvas cuadrado para la textura para que el desplazamiento pueda funcionar en ambos ejes
  const canvas = document.createElement('canvas');
  canvas.width = 1024; // Ancho de la textura (ambos ejes)
  canvas.height = 1024; // Alto de la textura
  console.log(canvas.width, canvas.height)

  const ctx = canvas.getContext('2d');
  
  // Generar un patrón futurista de piso con rejilla y brillo (neon)
  function generateTexture() {
    // Base oscura
    ctx.fillStyle = '#04060a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const cell = Math.max(12, Math.floor(canvas.width / 24)); // tamaño de celda adaptado al canvas
    for (let y = 0; y < canvas.height; y += cell) {
      for (let x = 0; x < canvas.width; x += cell) {
        // Dark panel
        ctx.fillStyle = '#07121a';
        ctx.fillRect(x + 2, y + 2, cell - 4, cell - 4);

        // Neon small lines
        const neon = Math.random() > 0.5 ? '#2f7bff' : '#ff6b2a';
        ctx.strokeStyle = neon;
        ctx.lineWidth = 1.6;
        ctx.shadowBlur = 10;
        ctx.shadowColor = neon;
        ctx.strokeRect(x + 3, y + 3, cell - 6, cell - 6);
      }
    }

    // pequeño ruido para dar texturizado
    const noiseDensity = 0.02;
    for (let i = 0; i < canvas.width * canvas.height * noiseDensity; i++) {
      const nx = Math.floor(Math.random() * canvas.width);
      const ny = Math.floor(Math.random() * canvas.height);
      ctx.fillStyle = 'rgba(255,255,255,' + (Math.random() * 0.03) + ')';
      ctx.fillRect(nx, ny, 1, 1);
    }
    ctx.shadowBlur = 0;
  }

  generateTexture(); // Generamos el fondo de suelo

  // Crear la textura a partir del canvas
  const textureBack = new THREE.CanvasTexture(canvas);
    textureBack.wrapS = THREE.RepeatWrapping;
    textureBack.wrapT = THREE.RepeatWrapping;
    // Repítelo varias veces para poder moverlo en ambos ejes
    textureBack.repeat.set(4, 4);
  
  // Crear el material usando la textura generada
  const material = new THREE.MeshStandardMaterial({
    map: textureBack,
    side: THREE.DoubleSide,
    metalness: 0.18,
    roughness: 0.35,
    emissive: new THREE.Color(0x001a2e),
    emissiveIntensity: 0.26
  });

  // Crear el plano de fondo
  const geometry = new THREE.PlaneGeometry(gridSize * 10, gridSize * 10);
  plane = new THREE.Mesh(geometry, material);
  try {
    plane.receiveShadow = true;
  } catch (e) {}
  material.transparent = true;  // Habilita la transparencia
  material.opacity = 0.5;       // Establece la opacidad al 50%
  plane.rotation.x = -Math.PI / 2; // Asegurarse de que esté horizontal
  //plane.position.set(0, -0.5, 0);
  plane.position.set(gridSize / 2 - 0.5, -0.5, gridSize / 2 - 0.5);
  scene.add(plane);
}

function updateBackground() {
  if (!plane || snake.length === 0) return;

  // Fondo se mueve en sentido contrario al gusano
  const head = snake[0];
   plane.position.set(
    -head.x + (gridSize),
    -0.5,
    -head.z + (gridSize / 2)
    );

  // (Opcional) animación de textura
  if (plane.material.map) {
    // Scroll the neon map depending on head position for dynamic motion
    // Use modulo to keep offsets in [0,1) so the repeating tile wraps
    const scrollFactor = 0.25; // increase to see movement
    plane.material.map.offset.x = ((head.x / gridSize) * scrollFactor) % 1.0;
    plane.material.map.offset.y = ((head.z / gridSize) * scrollFactor) % 1.0;
    plane.material.map.needsUpdate = true;
  }
}





function createCube(x, z, isHead = false, color = null) {
  const group = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.SphereGeometry(0.45, 16, 16),
    new THREE.MeshStandardMaterial({
      color: color ? color : (isHead ? 0x00cc00 : 0x00ff00),
      metalness: 0.2,
      roughness: 0.28,
      emissive: isHead ? new THREE.Color(0x002233) : new THREE.Color(0x001a00),
      emissiveIntensity: isHead ? 0.24 : 0.08
    })
  );
  body.position.set(0, 0, 0);
  group.add(body);

  if (isHead) {
    const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);

    const pupilGeo = new THREE.SphereGeometry(0.05, 8, 8);
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

    const pupil1 = new THREE.Mesh(pupilGeo, pupilMat);
    const pupil2 = new THREE.Mesh(pupilGeo, pupilMat);

    // Posiciones iniciales mirando hacia adelante (Z+)
    eye1.position.set(0.15, 0.15, 0.4);
    eye2.position.set(-0.15, 0.15, 0.4);
    pupil1.position.set(0.15, 0.15, 0.5);
    pupil2.position.set(-0.15, 0.15, 0.5);

    group.add(eye1, eye2, pupil1, pupil2);

    // Guarda referencias globales
    eyes = [eye1, eye2];
    pupils = [pupil1, pupil2];

    updateEyeDirection(); // Apunta ojos en la dirección actual
  }

  group.position.set(x, 0.5, z);
  try {
    // enable shadow casting for the snake
    body.castShadow = true;
  } catch (e) {}
  snakeGroup.add(group);
  return group;
}

function spawnParticles(pos, hexColor = 0xffffff, count = 10) {
  for (let i = 0; i < count; i++) {
    const g = new THREE.SphereGeometry(0.06 * Math.random() + 0.02, 8, 8);
    const mat = new THREE.MeshStandardMaterial({ color: hexColor, transparent: true, opacity: 1.0 });
    const spr = new THREE.Mesh(g, mat);
    spr.position.set(pos.x + (Math.random() - 0.5) * 0.6, pos.y + 0.1 + Math.random() * 0.2, pos.z + (Math.random() - 0.5) * 0.6);
    const angle = Math.random() * Math.PI * 2;
    const speed = 1.4 * (0.6 + Math.random() * 0.8);
    const vel = new THREE.Vector3(Math.cos(angle) * 0.6 * Math.random(), 0.6 + Math.random() * 1.4, Math.sin(angle) * 0.6 * Math.random()).multiplyScalar(speed);
    spr.castShadow = false;
    scene.add(spr);
    particles.push({ mesh: spr, vel: vel, life: 0.8 + Math.random() * 0.6, maxLife: 1.0, material: mat });
  }
}

// Create red & blue laser beams effect
function spawnLaserBeams(pos, count = 8) {
  // Create rays composed of small particles that move outward from the food
  for (let i = 0; i < count; i++) {
    const color = (i % 2 === 0) ? PALETTE.red : PALETTE.blue;
    const dir = new THREE.Vector3(Math.random() - 0.5, -0.2 + Math.random() * 0.8, Math.random() - 0.5).normalize();
    const segs = 6 + Math.floor(Math.random() * 5);
    const parts = [];
    for (let s = 0; s < segs; s++) {
      const size = 0.02 + Math.random() * 0.06;
      const g = new THREE.SphereGeometry(size, 8, 8);
      const m = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.95 - s * 0.06, blending: THREE.AdditiveBlending, depthWrite: false });
      const mpart = new THREE.Mesh(g, m);
      mpart.position.set(pos.x, pos.y + 0.15, pos.z);
      // add slight offset along direction
      mpart.position.addScaledVector(dir, s * (0.18 + Math.random() * 0.08));
      mpart.castShadow = false;
      scene.add(mpart);
      parts.push({ mesh: mpart, offset: s });
    }
    // Beam object: parts move outwards together
    beams.push({ parts, dir, life: 0.55 + Math.random() * 0.8, maxLife: 1.0, speed: 2.0 + Math.random() * 3 });
  }
}


function updateEyeDirection() {
  if (eyes.length < 2 || pupils.length < 2) return;

  if (direction.x === 1) {
    eyes[0].position.set(0.4, 0.15, 0.15);
    eyes[1].position.set(0.4, 0.15, -0.15);
    pupils[0].position.set(0.5, 0.15, 0.15);
    pupils[1].position.set(0.5, 0.15, -0.15);
  } else if (direction.x === -1) {
    eyes[0].position.set(-0.4, 0.15, 0.15);
    eyes[1].position.set(-0.4, 0.15, -0.15);
    pupils[0].position.set(-0.5, 0.15, 0.15);
    pupils[1].position.set(-0.5, 0.15, -0.15);
  } else if (direction.z === 1) {
    eyes[0].position.set(0.15, 0.15, 0.4);
    eyes[1].position.set(-0.15, 0.15, 0.4);
    pupils[0].position.set(0.15, 0.15, 0.5);
    pupils[1].position.set(-0.15, 0.15, 0.5);
  } else if (direction.z === -1) {
    eyes[0].position.set(0.15, 0.15, -0.4);
    eyes[1].position.set(-0.15, 0.15, -0.4);
    pupils[0].position.set(0.15, 0.15, -0.5);
    pupils[1].position.set(-0.15, 0.15, -0.5);
  }
}




function placeFood() {
  if (food) scene.remove(food);
  const geometry = new THREE.SphereGeometry(0.4, 16, 16);
  // Make the food a neon orange/red for contrast
  const material = new THREE.MeshStandardMaterial({ color: PALETTE.red });
  food = new THREE.Mesh(geometry, material);
  try {
    food.castShadow = true;
    material.metalness = 0.1;
    material.roughness = 0.4;
    material.emissive = new THREE.Color(PALETTE.orange);
    material.emissiveIntensity = 0.5;
    material.transparent = true;
  } catch (e) {}
  food.position.set(
    Math.floor(Math.random() * gridSize),
    0.5,
    Math.floor(Math.random() * gridSize)
  );
  scene.add(food);
}

function updateSnake() {
  const head = { ...snake[0] };
  head.x += direction.x;
  head.z += direction.z;

  if (
    head.x < 0 || head.x >= gridSize ||
    head.z < 0 || head.z >= gridSize ||
    snake.some(s => s.x === head.x && s.z === head.z)
  ) {
    gameOver = true;
    running = false;
    try { if (typeof soundManager !== 'undefined') soundManager.playGameOver(); } catch (e) {}
    //ui.innerText = `¡Perdiste!\nPuntaje: ${score}\nPresiona espacio o toca para reiniciar`;
    //ui.style.display = "flex";
    const overlay = document.getElementById('game-over-overlay');
    document.getElementById('final-score').textContent = score;
    overlay.setAttribute('aria-hidden', 'false');
    return;
  }

    const mesh = createCube(head.x, head.z, true, PALETTE.cyan); // nueva cabeza (neon)
    head.mesh = mesh;
    snake.unshift(head);

    // cambia la anterior cabeza a cuerpo
    if (snake.length > 1) {
    const oldHead = snake[1];
    snakeGroup.remove(oldHead.mesh);
    // alternate body color between blue/orange for neon look
    const bodyColor = (snake.length % 2 === 0) ? PALETTE.blue : PALETTE.orange;
    oldHead.mesh = createCube(oldHead.x, oldHead.z, false, bodyColor);
    snakeGroup.add(oldHead.mesh);
    }

  if (head.x === food.position.x && head.z === food.position.z) {
    score++;
    // Spawn particles and neon laser beams at the food position for feedback before relocating
    spawnParticles(food.position, PALETTE.cyan, 12);
    spawnLaserBeams(food.position, 10);
    try { if (typeof soundManager !== 'undefined') soundManager.playEat(); } catch (e) {}
    placeFood();
    try {
      const el = document.getElementById('score');
      if (el) {
        el.classList.add('pulse');
        setTimeout(() => el.classList.remove('pulse'), 260);
      }
    } catch (e) {}
  } else {
    const tail = snake.pop();
    snakeGroup.remove(tail.mesh);
  }
}

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  if (running && !gameOver) {
    moveTimer += dt;
    if (moveTimer >= moveInterval) {
      moveTimer = 0;
      updateSnake();
    }
  }

  // update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    if (p.material) p.material.opacity = Math.max(0, p.life / p.maxLife);
    if (p.life <= 0) {
      scene.remove(p.mesh);
      particles.splice(i, 1);
    }
  }

  // update beams (particles forming rays)
  for (let i = beams.length - 1; i >= 0; i--) {
    const b = beams[i];
    b.life -= dt;
    if (!b.parts) continue;
    // move each part outwards and fade
    for (let p = 0; p < b.parts.length; p++) {
      const partObj = b.parts[p];
      const m = partObj.mesh;
      // move along direction scaled by (offset + 1)
      m.position.addScaledVector(b.dir, dt * b.speed * (1 + partObj.offset * 0.2));
      if (m.material) m.material.opacity = Math.max(0, b.life / b.maxLife - partObj.offset * 0.04);
      // small scale growth while alive
      m.scale.x += dt * 0.6;
      m.scale.y += dt * 0.6;
      m.scale.z += dt * 0.6;
    }
    if (b.life <= 0) {
      for (let p = 0; p < b.parts.length; p++) {
        scene.remove(b.parts[p].mesh);
      }
      beams.splice(i, 1);
    }
  }

  // Animate border rays flashing like LED lights
  for (let ray of borderRays) {
    ray.material.emissiveIntensity = 0.2 + 0.8 * Math.sin(clock.elapsedTime * 6);
  }

  // Agitar el cuerpo del gusano
    for (let i = 0; i < snake.length; i++) {
    const part = snake[i];
    const wiggle = Math.sin(clock.elapsedTime * 4 + i * 0.5) * 0.1;
    part.mesh.position.y = 0.5 + wiggle;
    }

    // Llamar a la función de actualización del fondo
  updateBackground();
  renderer.render(scene, camera);
  document.getElementById('score').innerText = `Puntaje: ${score}`;
}
</script>
<script>
  // Rotate overlay logic: show overlay on mobile when viewport is portrait
  (function () {
    const overlay = document.getElementById('rotate-overlay');
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    if (!overlay) return;
    function updateRotateOverlay() {
      try {
        const isPortrait = window.innerHeight > window.innerWidth;
        if (isMobile && isPortrait) {
          overlay.classList.add('show');
          overlay.setAttribute('aria-hidden', 'false');
        } else {
          overlay.classList.remove('show');
          overlay.setAttribute('aria-hidden', 'true');
        }
      } catch (e) {
        /* ignore */
      }
    }
    window.addEventListener('resize', updateRotateOverlay);
    window.addEventListener('orientationchange', () => setTimeout(updateRotateOverlay, 200));
    // run on next tick to ensure sizes settled
    setTimeout(updateRotateOverlay, 50);
  })();
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KH9BH4C48G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-KH9BH4C48G');
</script>
</body>
</html>
