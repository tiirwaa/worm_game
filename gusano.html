<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gusano 3D</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
    }

    canvas {
      display: block;
    }
    #ui {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 24px;
      text-align: center;
      pointer-events: none;
    }

    #score {
    position: absolute;
    top: 12px;
    left: 12px;
    color: #fff;
    font-size: 18px;
    font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    z-index: 1000;
    padding: 8px 12px;
    background: linear-gradient(135deg, rgba(255,255,255,0.06), rgba(0,0,0,0.12));
    border-radius: 10px;
    -webkit-backdrop-filter: blur(6px) saturate(120%);
    backdrop-filter: blur(6px) saturate(120%);
    box-shadow: 0 6px 22px rgba(0,0,0,0.45);
    letter-spacing: 0.6px;
    transition: transform 180ms ease, box-shadow 160ms ease;
    will-change: transform;
    }

    #score.pulse { transform: scale(1.08); box-shadow: 0 10px 34px rgba(0,0,0,0.6); }

    #logo {
    position: absolute;
    top: 10px;
    right: 10px;
    height: 40px; /* o usa width si prefieres */
    z-index: 10;
    }

    #touch-controls {
    position: absolute;
    bottom: 20px;
    right: 20px;
    z-index: 1050;
    -webkit-user-select: none;
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: flex-end;
    pointer-events: auto;
    padding: 8px;
    border-radius: 12px;
    background: rgba(0,0,0,0.18);
    border: 1px solid rgba(255,255,255,0.06);
    box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    }

    #touch-controls .up {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 0;
    margin: 0px !important;
    margin-top: 3px !important;
    }

    #touch-controls .row {
    display: flex;
    justify-content: center;
    margin-top: 45px; /* Ajusta este valor si es necesario */
    }

    #touch-controls .btn {
    width: 48px;
    height: 48px;
    margin: 4px;
    font-size: 22px;
    background-color: rgba(255,255,255,0.2);
    border: 1px solid #fff;
    color: white;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    -webkit-backdrop-filter: blur(4px) saturate(120%);
    backdrop-filter: blur(4px) saturate(120%);
    }

    #touch-controls .btn:active {
    background-color: rgba(255,255,255,0.4);
    }

    /* Start overlay */
    #start-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      pointer-events: none;
    }
    #start-overlay[aria-hidden="true"] {
      display: none;
    }
    #game-over-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      pointer-events: none;
    }
    #game-over-overlay[aria-hidden="true"] {
      display: none;
    }
    #start-overlay .start-inner{
      pointer-events: auto;
      background: linear-gradient(180deg, rgba(8,10,12,0.9), rgba(0,0,0,0.76));
      border-radius: 16px;
      padding: 18px 26px;
      text-align: center;
      box-shadow: 0 18px 46px rgba(0,0,0,0.6);
      color: #fff;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    }
    #start-overlay .title { max-width: 250px; height: auto; margin: 0 auto; display: block; }
    #start-overlay .subtitle { margin-top:8px; opacity:0.9; }
    #start-overlay .start-inner button{
      margin-top: 14px;
      padding: 10px 18px;
      font-size: 18px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: linear-gradient(90deg,#ff7b00,#ff4500);
      color: white;
      box-shadow: 0 8px 22px rgba(255,123,0,0.18);
    }

    /* Game Over overlay styles - same as start overlay */
    #game-over-overlay .start-inner {
      pointer-events: auto;
      background: linear-gradient(180deg, rgba(8,10,12,0.9), rgba(0,0,0,0.76));
      border-radius: 16px;
      padding: 18px 26px;
      text-align: center;
      box-shadow: 0 18px 46px rgba(0,0,0,0.6);
      color: #fff;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    }
    #game-over-overlay .title { font-size:22px; font-weight:700; }
    #game-over-overlay .subtitle { margin-top:8px; opacity:0.9; }
    #game-over-overlay .start-inner button{
      margin-top: 14px;
      padding: 10px 18px;
      font-size: 18px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: linear-gradient(90deg,#ff7b00,#ff4500);
      color: white;
      box-shadow: 0 8px 22px rgba(255,123,0,0.18);
    }
    #rotate-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.88);
      color: #fff;
      z-index: 9999;
      visibility: hidden;
      opacity: 0;
      transition: opacity 220ms ease, visibility 220ms ease;
      pointer-events: none;
      font-family: sans-serif;
      text-align: center;
    }
    #rotate-overlay.show {
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    #rotate-overlay .rotate-inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 18px;
    }
    #rotate-overlay .rotate-icon {
      width: 96px;
      height: 96px;
      opacity: 0.98;
    }
    #rotate-overlay .rotate-text {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.6px;
    }
    @media (max-width:600px) {
      #rotate-overlay .rotate-icon { width: 72px; height:72px; }
      #rotate-overlay .rotate-text { font-size: 16px; }
    }

  </style>
</head>
<body>
<div id="ui"></div>

<!-- Rotate overlay: shown on mobile when in portrait orientation -->
<div id="rotate-overlay" class="" role="dialog" aria-hidden="true" tabindex="-1">
  <div class="rotate-inner" aria-hidden="true">
    <svg class="rotate-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M12 6V3L8 7l4 4V8c2.76 0 5 2.24 5 5 0 2.21-1.45 4.08-3.5 4.72" stroke="#ffffff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M20 6v6" stroke="#ffffff" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" opacity="0.85"/>
    </svg>
    <div class="rotate-text">Gira la pantalla</div>
  </div>
</div>
<div id="score">Puntaje: 0</div>
<img id="logo" src="logo.png" alt="Logo">
<div id="touch-controls">
  <button class="btn up">▲</button>
  <div class="row">
    <button class="btn left">◀</button>
    <button class="btn down">▼</button>
    <button class="btn right">▶</button>
  </div>
</div>
<!-- Optional Start overlay with CTA -->
<div id="start-overlay">
  <div class="start-inner">
    <img src="logoworm3d.png" alt="Gusano 3D" class="title">
    <div class="subtitle">Presiona 'Comenzar' o toca la pantalla para jugar</div>
    <button id="start-button">Comenzar</button>
  </div>
</div>
<!-- Game Over overlay with same design -->
<div id="game-over-overlay" aria-hidden="true">
  <div class="start-inner">
    <div class="title">¡Perdiste!</div>
    <div class="subtitle">Puntaje: <span id="final-score">0</span></div>
    <button id="restart-button">Reiniciar</button>
  </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.js"></script>
<script>
let scene, camera, renderer, clock;
let eyes = [];
let pupils = [];
let snake = [];
let direction = new THREE.Vector3(1, 0, 0);
let food;
let running = false;
let gameOver = false;
let moveTimer = 0;
let moveInterval = 0.15;
let score = 0;
let gridSize = 20;
let plane = null;
let textureBack = null;
let snakeGroup;
let particles = []; // small particle effects when eating
const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
const ui = document.getElementById('ui');

init();
createAnimatedBackground();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  /*camera.position.set(gridSize / 2, 25, gridSize * 1.2);
  camera.lookAt(gridSize / 2, 0, gridSize / 2);*/

  camera.position.set(gridSize / 2, 15, gridSize * 0.6); // Acercar la cámara a la escena
  camera.lookAt(gridSize / 2, 0, gridSize / 2); // Mantener el enfoque en el centro

  renderer = new THREE.WebGLRenderer({ antialias: true });
  // Shadows and better lighting for nicer visuals
  try {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  } catch (e) {}
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  

  clock = new THREE.Clock();

  // Luz
  const ambient = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambient);
  // Hemispheric light for soft sky/ground lighting
  const hemi = new THREE.HemisphereLight(0x8888ff, 0x222222, 0.25);
  scene.add(hemi);
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
  dirLight.position.set(10, 20, 10);
  // enable shadows for directional light
  try {
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 200;
  } catch (e) {}
  scene.add(dirLight);

  // Plano base
  const grid = new THREE.GridHelper(gridSize, gridSize, 0x888888, 0x444444);
  grid.position.set(gridSize / 2 - 0.5, -0.5, gridSize / 2 - 0.5);
  scene.add(grid);

  // Snake
  snakeGroup = new THREE.Group();
  scene.add(snakeGroup);

  document.addEventListener('keydown', onKey);
  document.addEventListener('touchstart', onTouch);
  window.addEventListener('resize', onWindowResize);

  if (true) {
    document.getElementById('touch-controls').style.display = 'block';

    //
    document.querySelector('#touch-controls .up').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.z !== 1) direction.set(0, 0, -1);
      updateEyeDirection();
    });
    document.querySelector('#touch-controls .down').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.z !== -1) direction.set(0, 0, 1);
      updateEyeDirection();
    });
    document.querySelector('#touch-controls .left').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.x !== 1) direction.set(-1, 0, 0);
      updateEyeDirection();
    });
    document.querySelector('#touch-controls .right').addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (direction.x !== -1) direction.set(1, 0, 0);
      updateEyeDirection();
    });
  }

  
  resetGame();
  //
  
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onKey(e) {
  if (e.code === "Space") {
    if (!running || gameOver) {
      startGame();
    }
  }
  if (e.key === "ArrowUp" || e.key === "w") if (direction.z !== 1) direction.set(0, 0, -1);
  if (e.key === "ArrowDown" || e.key === "s") if (direction.z !== -1) direction.set(0, 0, 1);
  if (e.key === "ArrowLeft" || e.key === "a") if (direction.x !== 1) direction.set(-1, 0, 0);
  if (e.key === "ArrowRight" || e.key === "d") if (direction.x !== -1) direction.set(1, 0, 0);
  updateEyeDirection();
}

function onTouch(e) {
  if (e.target.tagName === 'BUTTON') return; // don't start game on button click
  if (!running || gameOver) {
    startGame();
  }
}

function startGame() {
  resetGame();
  running = true;
  ui.style.display = "none";
  try {
    const overlay = document.getElementById('start-overlay');
    if (overlay) {
      if (overlay.contains(document.activeElement)) document.activeElement.blur();
      overlay.setAttribute('aria-hidden', 'true');
    }
    const goOverlay = document.getElementById('game-over-overlay');
    if (goOverlay) {
      if (goOverlay.contains(document.activeElement)) document.activeElement.blur();
      goOverlay.setAttribute('aria-hidden', 'true');
    }
  } catch (e) {}
}

// Setup start button so user can click to start
document.addEventListener('DOMContentLoaded', function () {
  try {
    const btn = document.getElementById('start-button');
    if (btn) btn.addEventListener('click', startGame);
    const restartBtn = document.getElementById('restart-button');
    if (restartBtn) restartBtn.addEventListener('click', resetGame);
  } catch (e) {}
});

function resetGame() {
  snake.forEach(part => snakeGroup.remove(part.mesh));
  snake = [];
  direction.set(1, 0, 0);
  snake.push({ x: 10, z: 10, mesh: createCube(10, 10, true) });
  moveTimer = 0;
  gameOver = false;
  running = false;
  score = 0;
  placeFood();
  //ui.innerText = "Presiona espacio o toca la pantalla para comenzar";
  ui.style.display = "flex";
  try {
    const goOverlay = document.getElementById('game-over-overlay');
    if (goOverlay) {
      if (goOverlay.contains(document.activeElement)) document.activeElement.blur();
      goOverlay.setAttribute('aria-hidden', 'true');
    }
    const startOverlay = document.getElementById('start-overlay');
    if (startOverlay) startOverlay.setAttribute('aria-hidden', 'false');
  } catch (e) {}
}





function createAnimatedBackground() {
  // Crear un canvas para la textura
  const canvas = document.createElement('canvas');
  canvas.width = 300; // Ancho de la textura
  canvas.height = 2000; // Alto de la textura
  console.log(canvas.width, canvas.height)

  const ctx = canvas.getContext('2d');
  
  // Generar un patrón simple de tierra o suelo
  function generateTexture() {
    const colors = [
      '#5c4424',  // marrón
      '#704c28',  // marrón más claro
      '#7e593d',  // marrón oscuro
      '#3e4a2a',  // verde
    ];

    for (let x = 0; x < canvas.width; x++) {
      for (let y = 0; y < canvas.height; y++) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        ctx.fillStyle = color;
        ctx.fillRect(x, y, 1, 1);  // Dibuja un pixel
      }
    }
  }

  generateTexture(); // Generamos el fondo de suelo

  // Crear la textura a partir del canvas
  const textureBack = new THREE.CanvasTexture(canvas);
    textureBack.wrapS = THREE.RepeatWrapping;
    textureBack.wrapT = THREE.RepeatWrapping;
    textureBack.repeat.set(1, 1); // puedes aumentar para ver más repeticiones
  
  // Crear el material usando la textura generada
  const material = new THREE.MeshStandardMaterial({
    map: textureBack,
    side: THREE.DoubleSide,
  });

  // Crear el plano de fondo
  const geometry = new THREE.PlaneGeometry(gridSize * 10, gridSize * 10);
  plane = new THREE.Mesh(geometry, material);
  try {
    plane.receiveShadow = true;
  } catch (e) {}
  material.transparent = true;  // Habilita la transparencia
  material.opacity = 0.5;       // Establece la opacidad al 50%
  plane.rotation.x = -Math.PI / 2; // Asegurarse de que esté horizontal
  //plane.position.set(0, -0.5, 0);
  plane.position.set(gridSize / 2 - 0.5, -0.5, gridSize / 2 - 0.5);
  scene.add(plane);
}

function updateBackground() {
  if (!plane || snake.length === 0) return;

  // Fondo se mueve en sentido contrario al gusano
  const head = snake[0];
   plane.position.set(
    -head.x + (gridSize),
    -0.5,
    -head.z + (gridSize / 2)
    );

  // (Opcional) animación de textura
  if (plane.material.map) {
    //plane.material.map.offset.y += 0.002;
    plane.material.map.needsUpdate = true;
  }
}





function createCube(x, z, isHead = false) {
  const group = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.SphereGeometry(0.45, 16, 16),
    new THREE.MeshStandardMaterial({
      color: isHead ? 0x00cc00 : 0x00ff00,
      metalness: 0.1,
      roughness: 0.45,
      emissive: isHead ? new THREE.Color(0x002200) : new THREE.Color(0x001f00),
      emissiveIntensity: isHead ? 0.06 : 0.02
    })
  );
  body.position.set(0, 0, 0);
  group.add(body);

  if (isHead) {
    const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

    const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
    const eye2 = new THREE.Mesh(eyeGeo, eyeMat);

    const pupilGeo = new THREE.SphereGeometry(0.05, 8, 8);
    const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

    const pupil1 = new THREE.Mesh(pupilGeo, pupilMat);
    const pupil2 = new THREE.Mesh(pupilGeo, pupilMat);

    // Posiciones iniciales mirando hacia adelante (Z+)
    eye1.position.set(0.15, 0.15, 0.4);
    eye2.position.set(-0.15, 0.15, 0.4);
    pupil1.position.set(0.15, 0.15, 0.5);
    pupil2.position.set(-0.15, 0.15, 0.5);

    group.add(eye1, eye2, pupil1, pupil2);

    // Guarda referencias globales
    eyes = [eye1, eye2];
    pupils = [pupil1, pupil2];

    updateEyeDirection(); // Apunta ojos en la dirección actual
  }

  group.position.set(x, 0.5, z);
  try {
    // enable shadow casting for the snake
    body.castShadow = true;
  } catch (e) {}
  snakeGroup.add(group);
  return group;
}

function spawnParticles(pos, hexColor = 0xffffff, count = 10) {
  for (let i = 0; i < count; i++) {
    const g = new THREE.SphereGeometry(0.06 * Math.random() + 0.02, 8, 8);
    const mat = new THREE.MeshStandardMaterial({ color: hexColor, transparent: true, opacity: 1.0 });
    const spr = new THREE.Mesh(g, mat);
    spr.position.set(pos.x + (Math.random() - 0.5) * 0.6, pos.y + 0.1 + Math.random() * 0.2, pos.z + (Math.random() - 0.5) * 0.6);
    const angle = Math.random() * Math.PI * 2;
    const speed = 1.4 * (0.6 + Math.random() * 0.8);
    const vel = new THREE.Vector3(Math.cos(angle) * 0.6 * Math.random(), 0.6 + Math.random() * 1.4, Math.sin(angle) * 0.6 * Math.random()).multiplyScalar(speed);
    spr.castShadow = false;
    scene.add(spr);
    particles.push({ mesh: spr, vel: vel, life: 0.8 + Math.random() * 0.6, maxLife: 1.0, material: mat });
  }
}


function updateEyeDirection() {
  if (eyes.length < 2 || pupils.length < 2) return;

  if (direction.x === 1) {
    eyes[0].position.set(0.4, 0.15, 0.15);
    eyes[1].position.set(0.4, 0.15, -0.15);
    pupils[0].position.set(0.5, 0.15, 0.15);
    pupils[1].position.set(0.5, 0.15, -0.15);
  } else if (direction.x === -1) {
    eyes[0].position.set(-0.4, 0.15, 0.15);
    eyes[1].position.set(-0.4, 0.15, -0.15);
    pupils[0].position.set(-0.5, 0.15, 0.15);
    pupils[1].position.set(-0.5, 0.15, -0.15);
  } else if (direction.z === 1) {
    eyes[0].position.set(0.15, 0.15, 0.4);
    eyes[1].position.set(-0.15, 0.15, 0.4);
    pupils[0].position.set(0.15, 0.15, 0.5);
    pupils[1].position.set(-0.15, 0.15, 0.5);
  } else if (direction.z === -1) {
    eyes[0].position.set(0.15, 0.15, -0.4);
    eyes[1].position.set(-0.15, 0.15, -0.4);
    pupils[0].position.set(0.15, 0.15, -0.5);
    pupils[1].position.set(-0.15, 0.15, -0.5);
  }
}




function placeFood() {
  if (food) scene.remove(food);
  const geometry = new THREE.SphereGeometry(0.4, 16, 16);
  const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
  food = new THREE.Mesh(geometry, material);
  try {
    food.castShadow = true;
    material.metalness = 0.1;
    material.roughness = 0.4;
    material.emissive = new THREE.Color(0x220000);
    material.emissiveIntensity = 0.1;
    material.transparent = true;
  } catch (e) {}
  food.position.set(
    Math.floor(Math.random() * gridSize),
    0.5,
    Math.floor(Math.random() * gridSize)
  );
  scene.add(food);
}

function updateSnake() {
  const head = { ...snake[0] };
  head.x += direction.x;
  head.z += direction.z;

  if (
    head.x < 0 || head.x >= gridSize ||
    head.z < 0 || head.z >= gridSize ||
    snake.some(s => s.x === head.x && s.z === head.z)
  ) {
    gameOver = true;
    running = false;
    //ui.innerText = `¡Perdiste!\nPuntaje: ${score}\nPresiona espacio o toca para reiniciar`;
    //ui.style.display = "flex";
    const overlay = document.getElementById('game-over-overlay');
    document.getElementById('final-score').textContent = score;
    overlay.setAttribute('aria-hidden', 'false');
    return;
  }

    const mesh = createCube(head.x, head.z, true); // nueva cabeza
    head.mesh = mesh;
    snake.unshift(head);

    // cambia la anterior cabeza a cuerpo
    if (snake.length > 1) {
    const oldHead = snake[1];
    snakeGroup.remove(oldHead.mesh);
    oldHead.mesh = createCube(oldHead.x, oldHead.z, false);
    snakeGroup.add(oldHead.mesh);
    }

  if (head.x === food.position.x && head.z === food.position.z) {
    score++;
    // Spawn particles at the food position for feedback before relocating
    spawnParticles(food.position, 0xffb400, 12);
    placeFood();
    try {
      const el = document.getElementById('score');
      if (el) {
        el.classList.add('pulse');
        setTimeout(() => el.classList.remove('pulse'), 260);
      }
    } catch (e) {}
  } else {
    const tail = snake.pop();
    snakeGroup.remove(tail.mesh);
  }
}

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  if (running && !gameOver) {
    moveTimer += dt;
    if (moveTimer >= moveInterval) {
      moveTimer = 0;
      updateSnake();
    }
  }

  // update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life -= dt;
    p.mesh.position.addScaledVector(p.vel, dt);
    if (p.material) p.material.opacity = Math.max(0, p.life / p.maxLife);
    if (p.life <= 0) {
      scene.remove(p.mesh);
      particles.splice(i, 1);
    }
  }

  // Agitar el cuerpo del gusano
    for (let i = 0; i < snake.length; i++) {
    const part = snake[i];
    const wiggle = Math.sin(clock.elapsedTime * 4 + i * 0.5) * 0.1;
    part.mesh.position.y = 0.5 + wiggle;
    }

    // Llamar a la función de actualización del fondo
  updateBackground();
  renderer.render(scene, camera);
  document.getElementById('score').innerText = `Puntaje: ${score}`;
}
</script>
<script>
  // Rotate overlay logic: show overlay on mobile when viewport is portrait
  (function () {
    const overlay = document.getElementById('rotate-overlay');
    const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    if (!overlay) return;
    function updateRotateOverlay() {
      try {
        const isPortrait = window.innerHeight > window.innerWidth;
        if (isMobile && isPortrait) {
          overlay.classList.add('show');
          overlay.setAttribute('aria-hidden', 'false');
        } else {
          overlay.classList.remove('show');
          overlay.setAttribute('aria-hidden', 'true');
        }
      } catch (e) {
        /* ignore */
      }
    }
    window.addEventListener('resize', updateRotateOverlay);
    window.addEventListener('orientationchange', () => setTimeout(updateRotateOverlay, 200));
    // run on next tick to ensure sizes settled
    setTimeout(updateRotateOverlay, 50);
  })();
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KH9BH4C48G"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-KH9BH4C48G');
</script>
</body>
</html>
